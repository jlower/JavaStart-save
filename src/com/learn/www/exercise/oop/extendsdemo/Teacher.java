package com.learn.www.exercise.oop.extendsdemo;

/**
 * @author lowo
 * 2021/10/5->23:51
 */

//一、继承性的好处：
//①减少了代码的元余，提高了代码的复用性
//②便于功能的扩展
//③为之后多态性的使用，提供了前提

//extends 继承     class A extends B{}
//A:子类、派生类、subclass
//B:父类、超类、基类、superclass
//体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的结构：属性、方法
//特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。
//只是因为封装性的影响使得子类不能直接调用父类的结构而已。
//2.2子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展
//子类和父类的关系，不同于子集和集合的关系。
//extends：延展、扩展
//三、Java中关干继承性的规定
//1.一个类可以被多个子类继承。
//2.Java中类的单继承性：一个类只能有一个父类,单继承
//3.子父类是相对的概念。
//4.子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类 [祖先类]
//5.子类继承父类以后，就获取了直接父类以及所有间接父类[祖先类]中声明的属性和方法

//四、java.lang.Object类
//1.如果我们没有显式的声明一个个类的父类的话，则此类继承于java.lang.Object类
//2.所有的java类（除java.lang.Object类之外）都直接或间接的继承于java.lang.Object类
//3.意味着，所有的java类具有java.lang.Object类声明的功能

//super关键字的使用
//1.super理解为：父类的
//2.super可以用来调用：属性、方法、构造器
//3.super的使用
//      3.1我们可以在子类的方法或构造器中。通过使用“super.属性“或“super.方法“的方式，
//      显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略“super“
//      3.2特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的
//      使用“super.属性“的方式，表明调用的是父类中声明的属性
//      3.3特殊情况：当子类重写了父类中的方法以后，我们想在子类方中调用父类中被重写后的方法时，则必须显式的
//      调用"super.方法"的方式，表明调用的是父类中被重写后的方法。
//4.super调用构造器
//        4.1我们可以在子类的构造器中显式的使用“super(形参列表)“的方式，调用父类中声明的指定的构造器
//        4.2super“(形参列表)“的使用，必须声明在子类构造器的首行！
//        4.3我们在类的构造器中，针对于"this(形参列表)"或"super(形参列表)"只能二选一
//        4.4在构造器的首行，没有显式的声明"this(形参列表)"或"super(形参列表)"
//              则默认调用的是父类中的空参构造器即"super()" [若父类没有空参构造器则会报错]
//        4.5在类的多个构造器中，至少有一个类的构造器中使用了"super(形参列表)",调用父类中的构造器

//子类对象实例化的全过程
//1.从结果上来看：（继承性）
//      子类继承父类以后，就获取了父类中声明的属性或方法。创建子类的对象，在堆空间中，就会加载所有父类中声明的属性
//2.从过程上来看
//        当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器
//        直到调用了java.lang.Object类中的空参构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有
//        父类中的结构，子类对象才可以考虑对父类中的结构进行调用
//明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就只创建过一个对象，即为  new出来的子类对象。

public class Teacher extends Person{
    // ctrl + h 打开继承关系树
    //子类继承了父类就会有父类的全部public方法
    //在JAVA中所有类都默认直接或简接继承Object
    //JAVA只能单继承       一个儿子只能有一个爸爸,一个爸爸能有多个儿子
    private String name = "jlower";

    public void print(){
        System.out.println("Teacher.print!!");
    }

    public Teacher() {
        super();//隐藏代码   super(); 调用父类的无参构造  且必须在子类构造器的第一行
        //所以要继承则一般有无参构造
        //super必须只出现在子类方法/构造方法中
        //this();与super();不能同时调用构造方法
        //this(); 调用本类的无参构造
        //super("sdf");可以调用有参构造
        System.out.println("Teacher的无参构造");
    }

    public void test2(){
        print();//Teacher的print方法
        this.print();//Teacher的print方法
        super.print();//Person的print方法

    }
    public void test(String name){
        System.out.println("name = " + name);//传递的参数
        System.out.println("this.name = " + this.name);//Teacher自己类的name
        System.out.println("super.name = " + super.name);//父类Person的name
    }

}
