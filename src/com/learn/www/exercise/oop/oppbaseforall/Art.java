package com.learn.www.exercise.oop.oppbaseforall;

/**
 * @author lowo
 * 2021/10/11->20:56
 */


//我们将类的属性XXX私有化（private），同时，提供公共的（public）方法来获取（getXxx）和设置（setXxx）
//不对外暴露的私有的方法

//三、封装性的体现，需要权限修饰符来配合
//Java规定的4种权限（从小到大排列）：private、缺省(default)、protected、public

//4种权限可以用来修饰类及类的内部结构：属性、方法、构造器、内部类
//具体的，4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类
//修饰类的话，只能使用：缺省、public

//公共类型 public ；
//public可以修饰类，成员变量，构造方法，方法成员。
//被public修饰的成员，可以在任何一个类中被调用，不管同包或不同包，是权限最大的一个修饰符//同一个工程中
//保护类型 protect；
//可以修饰数据成员，构造方法，方法成员，不能修饰类（此处指外部类，不考虑内部类）。
//被protected修饰的成员，能在定义它们的类中，同包的类中被调用。
//如果有不同包的类想调用它们，那么这个类必须是定义它们的类的子类。
//***********被 protected 修饰的成员对于本包和其子类可见：***************
//1.基类的 protected 成员在包内可见
//2.若继承了基类的子类与基类不在同一个包中，那么在子类中，
// 子类实例可以访问其从基类继承而来的 protected 方法，不能访问基类中的 protected 方法。
//默认类型 default；
//可用于修饰类，成员变量，构造方法，方法，都能够使用默认权限，即不写任何关键字。
//默认权限即同包权限，同包权限的元素只能在定义它们的类中，以及同包的类中被调用。
//私有类型 private；
//可以修饰成员变量，构造方法，成员方法，不能修饰类（此处指外部类，不考虑内部类）。
//被private修饰的成员，只能在定义它们的类中使用，在其他类中不能调用。

//在一个类中可以声明另一个类的对象  [这两个类是关联关系]
//连续操作 bank.getCustomer(e).setAccount(new Account(2000);
//    bank.getCustomer(e)返回一个对象x   再用  x.setAccount(new Account(2000);

//6.在类前，方法前，方法内具体逻辑的实现步骤等添加必要的注释:
//类前、方法前、属性前：文档注释。
//逻辑步骤：单行、多行注释

//面向对象特征之三：多态性
//理解多态性：可以理解为一个事物的多种形态。
//何为多态性：对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用） eg. Person p2 = new Man();
//多态的使用：当调用子父类同名同参数的方法时，实际执行的是子类重写父类的方法---虚拟方法调用[父类的引用指向子类的对象]
//多态的使用：虚拟方法调用          Person p2 = new Man();编译看左边，运行看右边！
//有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。
//总结：编译，看左边；运行，看右边。
//多态性的使用前提：①类的继承关系②方法的重写
//******对象的多态性只适用于方法，不适用于属性（属性的编译和运行都看左边）********

//虚拟方法调用（多态情况下）: 父类不能调用子类所特有的方法：编译时，只能调用父类中声明的方法   运行期
//子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，
//父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。
//方法的调用是在运行时确定的
//编译时类型和运行时类型  ----  动态绑定

//从编译和运行的角度看:
//重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。
//对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。
//Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。
//所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；
//而对于多态，只有等到方法调用的那一刻，编译器才会确定所要调用的具体方法这称为“晚绑定”或“动态绑定”    [eg.重写]

//引用一句BruceEckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。

//为什么super(...）或this（...）调用语句只能作为构造器中的第一句出现？
//无论通过哪个构造器创建子类对象，需要保证先初始化父类
//目的：当子类继承父类后，“继承“父类中所有的属性和方法，因此子类有必要知道父类如何为对象进行初始

//方法的重写规则
//参数列表与被重写方法的参数列表必须完全相同。[    int... 与 int[] arr  认为是相同的](...等同于数组)
//返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类
//（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。
//访问权限不能比父类中被重写的方法的访问权限更低。
//例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。
//父类的成员方法只能被它的子类重写。
//声明为 final 的方法不能被重写。
//声明为 static 的方法不能被重写，但是能够被再次声明。
//子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。
//子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。
//重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。
//但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
//构造方法不能被重写。
//如果不能继承一个类，则不能重写该类的方法。



public class Art {
    public static void main(String[] args) {
        //有了对象的多态性以后，内存中实际上是加载了子类持有的属性和方法的，但是由于变量声明为父类类型，
        //导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。
        //如何才能调用子类特有的属性和方法？
        //向下转型：使用强制类型转换符。[不相关的类型不能转]
        //使用强转时，可能出ClassCastException的异常。
        //instanceof关键字的使用
        //a instanceof A: 判断对象a 是否是类A 的实例。如果是，返回true；如果不是，返回false。
        //eg. Person p1 = new Man();//要使用子类Man特有的属性和方法要用强制类型转换符
        //    //实例化指定了new Man();则只能强制转换为Man或Man的祖先类  不能转化为Man的子类
        //    if(p1 instanceof Man){//先判断p1实例化的对象是不是子类Man    p1的引用类型为父类Person
        //          Man m1 = (Man)p1;//强制类型转换
        //          Object o1 = (Object)p1;
        //          //因为Object类为Man类的祖先类
        //          //所以p1 instanceof Man返回true时p1 instanceof Object也应该返回true,则可以强制类型转换
        //    }
        //使用情境：为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，
        //先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型
        //类B是类A的  祖先  。如果a instanceof A返回true，则a instanceof B也返回true


        //1.若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法
        //系统将不可能把父类里的方法转移到子类中：编译看左边，运行看右边
        //2.对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量
        //这个实例变量依然不可能覆盖父类中定义的实例变量：编译运行都看左边
        Sub s = new Sub();
        Base b = s;
        //  ==  对于引用数据类型来讲，比较的是两个引用数据类型变量的地址值是否相同
        System.out.println(b == s);
        //******对象的多态性只适用于方法，不适用于属性（属性的编译和运行时所取值都看左边）********
        //b左边类型为Base所以b.count拿的时左边类型为Base中的count属性值10
        System.out.println("b.count = " + b.count);//10
        b.display();//20   多态用子方法中重写的方法
        Base b2 = new Sub();
        b2.doit(1,2,3);//Sub_1 //重写
        Sub s2 = (Sub)b2;//不能(Sub)b2.doit(1,2,3);
        s2.doit(1,2,3);//Sub_2 //Sub类中不优先匹配[   数组/...   ]
    }
}
class Base{
    int count = 10;
    public void display(){
        System.out.println(count);//this.count
    }
    public void doit(int a,int... ints){
        System.out.println("Base_1");
    }
}
class Sub extends Base{
    int count = 20;
    public void display(){
        System.out.println(count);//this.count
    }
    public void doit(int a,int[] arr){
        System.out.println("Sub_1");
    }
    public void doit(int a,int b,int c){
        System.out.println("Sub_2");
    }
}

